#include<iostream>

//using namespace std;	// C++库中的所有东西都是放到std命名空间中的
// 日常状态下，如果变量名少，不在乎变量名冲突，那么就可以将std直接展开
// 但是，这样展开会有一个缺点：如果程序员定义的变量名和std内部的名字相同就会出现冲突

using std::cout;
using std::cin;
using std::endl;
// 这种方式表示将std内部的一部分函数或者内容展开，此时可以直接调用展开部分；未展开部分调用则仍需要std的引用
// 一般是将常用的对象或者类型展开
// 工程项目中常用

// 例如，要想打印hello world，就需要利用到cout输出流函数
// 但是这个函数是被放到命名空间中的。
// 所以，要么提前将命名空间std（标准输入输出）声明好；要么就在使用到cout函数时将std带上
// 比如： std::cout<<"hello world";
//

//int main()
//{
//	//cout << "hello world!!\n"<<endl;	// 引用std命名空间之后的cout函数调用
//	// 这里的endl表示的也是换行符号的作用，和“\n”的效果相同
//	// 同时，endl调用和cout调用一样，也需要std的提前声明或者std的展开
//	//std::cout << "hello world";	// 未引用std命名空间后的调用方法
//	/*std::cout << "hello world"<<std::endl;*/
//
//	// 通过以下代码，可以发现C++的cout函数可以做到自动识别数据类型，不需要指定类型
//	// 这种能力是通过函数重载实现的
//	int i = 1;
//	double d = 1.11;
//	cin >> i >> d;
//	// 将控制台输入的数据分别流向变量i和变量d
//	std::cout << "i = "<< i << " " << "d = " << d << std::endl;
//
//	return 0;
//}


// 缺省参数
// 
//void Func(int a)
//{
//	cout << a << endl;
//}

// 这里面的形参a = 0就是缺省参数
// 如果在调用的时候没有对Func函数传入参数，那么就将缺省参数作为实参传入函数进行运行
// 可以理解为缺省参数就是备胎的意思
//void Func(int a = 0)
//{
//	cout << a << endl;
//}

// 缺省参数也有两种：
// 1、全缺省
// 2、半缺省
// 
// 注意：
// 不管是什么样子的缺省参数
// 1、调用时传参默认从左往右依次传入。即不能跳着传参
// 2、缺省的参数必须从右往左依次缺省。不能三个形参只有中间缺省
//

//static void Func1(int a = 10, int b = 20, int c = 30)
//{
//	cout << "a = " << a << endl;
//	cout << "b = " << b << endl;
//	cout << "c = " << c << endl;
//}
//
//int main()
//{
//	//Func(10);
//	//Func();
//
//	Func1();
//	Func1(1);
//	Func1(1, 2);
//	Func1(1, 2, 3);
//	return 0;
//}

//
// 函数重载：本质上是相同函数名的不同函数（包括类型不同/参数个数不同/参数顺序不同）
// 例如：
// 类型不同
//int add(int left, int right)
//{
//	return left + right;
//}
//
//long add(long left, long right)
//{
//	return left + right;
//}
//
//// 顺序不同
//void func1(int i, char c)
//{
//
//}
//
//void func1(char c, int i)
//{
//
//}
// 如果只有返回值类型不同，就不能构成重载函数
// 
// 调用时，编译器会根据你输入的参数默认选择对应的函数
// 例如：add(1, 2)
//		 编译器会默认使用int类型的函数
// 例如：add(1L,2L)
//		 加上L后，编译器会自动识别并使用long类型定义的函数
// C++支持重载函数，C不支持 
// 
//重载面试问题：
// 1、什么是重载函数
// 2、C++是如何支持函数重载的？为什么C语言不支持

// 对于一个源代码文件
// list.h	list.c	test.c
// 将其生成为可执行文件需要四步：预处理、编译、汇编、链接
// 1、预处理	->头文件展开/宏替换/条件编译/去掉注释
//			list.i	test.i
// 2、编译		->检查语法，生成汇编代码（汇编代码CPU看不懂，不能执行，所以需要汇编将汇编代码变成二进制机器码）
//			list.s	test.s
// 3、汇编		->将汇编代码转成二进制机器码
//			list.o	test.o
// 4、链接		->将两个目标文件链接到一起，并生成可执行文件
// 
// 在C语言编译方式下，生成的汇编代码直接用函数名表示函数，如果有相同的函数名则无法区分
// 在C++的编译方式下，由于增加了函数修饰，将函数的参数类型和参数名作为编译生成的符号表所代表的函数的一部分，因此可以使用相同的函数名形成重载函数
//

// extern关键字：
// 当使用C++实现静态库或者动态库时，C++的编译可以调用，但C语言不能调用
// 如果需要让C程序调用，就可以在调用函数前加一个extern，使编译器使用C语言的方式编译库
// 而C++是可以兼容C语言的编译方式的，此时C++和C就都可以调用该静态库或者动态库
//



//
// 引用
int main()
{
	int a = 1;
	int& ra = a;	
	// 这里的&就是引用符号
	// 生成的变量ra就是原变量空间a的一个别名
	// 不管是a，还是ra他们都是同一个变量空间的别名
	return 0;
}
//
// 引用的特性：
// 1、必须在定义的时候初始化
// 2、引用的别名ra类型仍然是int
// 3、别名的权限一定是小于或等于原变量的权限的
//		即可读可写的变量是可以赋予一个只读的别名，但是只读的别名不能赋予一个可读可写的别名
//		int a = 1;
//		const int& b = a;
//		这样的引用是成立的，但反过来是不成立的
//
