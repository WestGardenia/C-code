#include<iostream>

//using namespace std;	// C++库中的所有东西都是放到std命名空间中的
// 日常状态下，如果变量名少，不在乎变量名冲突，那么就可以将std直接展开
// 但是，这样展开会有一个缺点：如果程序员定义的变量名和std内部的名字相同就会出现冲突

using std::cout;
using std::cin;
using std::endl;
// 这种方式表示将std内部的一部分函数或者内容展开，此时可以直接调用展开部分；未展开部分调用则仍需要std的引用
// 一般是将常用的对象或者类型展开
// 工程项目中常用

// 例如，要想打印hello world，就需要利用到cout输出流函数
// 但是这个函数是被放到命名空间中的。
// 所以，要么提前将命名空间std（标准输入输出）声明好；要么就在使用到cout函数时将std带上
// 比如： std::cout<<"hello world";
//

//int main()
//{
//	//cout << "hello world!!\n"<<endl;	// 引用std命名空间之后的cout函数调用
//	// 这里的endl表示的也是换行符号的作用，和“\n”的效果相同
//	// 同时，endl调用和cout调用一样，也需要std的提前声明或者std的展开
//	//std::cout << "hello world";	// 未引用std命名空间后的调用方法
//	/*std::cout << "hello world"<<std::endl;*/
//
//	// 通过以下代码，可以发现C++的cout函数可以做到自动识别数据类型，不需要指定类型
//	// 这种能力是通过函数重载实现的
//	int i = 1;
//	double d = 1.11;
//	cin >> i >> d;
//	// 将控制台输入的数据分别流向变量i和变量d
//	std::cout << "i = "<< i << " " << "d = " << d << std::endl;
//
//	return 0;
//}


// 缺省参数
// 
//void Func(int a)
//{
//	cout << a << endl;
//}

// 这里面的形参a = 0就是缺省参数
// 如果在调用的时候没有对Func函数传入参数，那么就将缺省参数作为实参传入函数进行运行
// 可以理解为缺省参数就是备胎的意思
//void Func(int a = 0)
//{
//	cout << a << endl;
//}

// 缺省参数也有两种：
// 1、全缺省
// 2、半缺省
// 
// 注意：
// 不管是什么样子的缺省参数
// 1、调用时传参默认从左往右依次传入。即不能跳着传参
// 2、缺省的参数必须从右往左依次缺省。不能三个形参只有中间缺省
//

//static void Func1(int a = 10, int b = 20, int c = 30)
//{
//	cout << "a = " << a << endl;
//	cout << "b = " << b << endl;
//	cout << "c = " << c << endl;
//}
//
//int main()
//{
//	//Func(10);
//	//Func();
//
//	Func1();
//	Func1(1);
//	Func1(1, 2);
//	Func1(1, 2, 3);
//	return 0;
//}

//
// 函数重载：本质上是相同函数名的不同函数（包括类型不同/参数个数不同/参数顺序不同）
// 例如：
// 类型不同
//int add(int left, int right)
//{
//	return left + right;
//}
//
//long add(long left, long right)
//{
//	return left + right;
//}
//
//// 顺序不同
//void func1(int i, char c)
//{
//
//}
//
//void func1(char c, int i)
//{
//
//}
// 如果只有返回值类型不同，就不能构成重载函数
// 
// 调用时，编译器会根据你输入的参数默认选择对应的函数
// 例如：add(1, 2)
//		 编译器会默认使用int类型的函数
// 例如：add(1L,2L)
//		 加上L后，编译器会自动识别并使用long类型定义的函数
// C++支持重载函数，C不支持 
// 
//重载面试问题：
// 1、什么是重载函数
// 2、C++是如何支持函数重载的？为什么C语言不支持

// 对于一个源代码文件
// list.h	list.c	test.c
// 将其生成为可执行文件需要四步：预处理、编译、汇编、链接
// 1、预处理	->头文件展开/宏替换/条件编译/去掉注释
//			list.i	test.i
// 2、编译		->检查语法，生成汇编代码（汇编代码CPU看不懂，不能执行，所以需要汇编将汇编代码变成二进制机器码）
//			list.s	test.s
// 3、汇编		->将汇编代码转成二进制机器码
//			list.o	test.o
// 4、链接		->将两个目标文件链接到一起，并生成可执行文件
// 
// 在C语言编译方式下，生成的汇编代码直接用函数名表示函数，如果有相同的函数名则无法区分
// 在C++的编译方式下，由于增加了函数修饰，将函数的参数类型和参数名作为编译生成的符号表所代表的函数的一部分，因此可以使用相同的函数名形成重载函数
//

// extern关键字：
// 当使用C++实现静态库或者动态库时，C++的编译可以调用，但C语言不能调用
// 如果需要让C程序调用，就可以在调用函数前加一个extern，使编译器使用C语言的方式编译库
// 而C++是可以兼容C语言的编译方式的，此时C++和C就都可以调用该静态库或者动态库
//



//
// 引用
//int main()
//{
//	int a = 1;
//	int& ra = a;	
//	// 这里的&就是引用符号
//	// 生成的变量ra就是原变量空间a的一个别名
//	// 不管是a，还是ra他们都是同一个变量空间的别名
//	return 0;
//}
//
// 引用的特性：
// 1、必须在定义的时候初始化
// 2、引用的别名ra类型仍然是int
// 3、别名的权限一定是小于或等于原变量的权限的
//		即可读可写的变量是可以赋予一个只读的别名，但是只读的别名不能赋予一个可读可写的别名
//		int a = 1;
//		const int& b = a;
//		这样的引用是成立的，但反过来是不成立的
//


// 内联函数
// 对于一些频繁调用的函数，例如swap交换函数、add相加函数，频繁调用会创建大量栈帧，产生大量消耗
// C语言中，采用宏函数的方法避免这种情况，可以在预处理的时候就完成这部分的逻辑实现
// 但有一定缺点：	1、不能调试
//					2、代码可读性较差
// C++中，采用内联函数解决这种问题
//	例如
//inline void Swap(int& a, int& b)
//{
//	int temp = a;
//	a = b;
//	b = temp;
//}
//
//int main()
//{
//	int a = 1, b = 2;
//	Swap(a, b);
//
//	return 0;
//}
// 当在频繁调用的函数前加了inline，就会使其变成内联函数
// 内联函数会时函数在编译阶段（变成汇编过程）就将其展开，不会创建函数栈帧，因此没有相应消耗
// 内联函数就是一种空间换时间的方法，是一种提升程序的性能的方法，主要用于程序的优化
// 内联函数只适合比较短的小型函数
// 对于大型函数或者递归函数，内联函数就变得不再适用
// 同时，内联也并不是一定加了inline就会成为内联函数，这实际上是给了编译器一个建议，可以进行内联函数的优化，但如果函数本身过长或者不适合内敛，编译器就不会将其内联
// 

// 自动推导变量：auto关键字
// 例如：
//int main()
//{
//	int a = 0;
//	auto b = a;	// b的类型是根据a的类型推导出是int
//	int& c = a;
//
//	cout << typeid(a).name() << endl;
//	cout << typeid(b).name() << endl;
//	cout << typeid(c).name() << endl;
//
//	return 0;
//}
// auto不能使用的场景：
// 1、auto不能作为参数
// 2、auto不能定义数组
// 
// auto主要适用于当变量的类型比较繁琐复杂时，可以简化代码的实现
//



// 范围for
// 将数组中的元素乘二并打印

//int main()
//{
//	int array[] = { 1,2,3,4,5,6 };
//	// 1、C语言版本
//	for (int i = 0; i < sizeof(array)/sizeof(int); i++)
//	{
//		array[i] *= 2;
//	}
//	for (int i = 0; i < sizeof(array)/sizeof(int); i++)
//	{
//		cout << array[i] << " ";
//	}
//	cout << endl;
//
//	// 2、C++范围for（语法糖）
//	// 注意auto后要加&，表示e是array数组的别名，而不是将array中的数据给e
//	// 同时，这种用法不能用于函数，因为数组在传参后会退化成指针，而这种用法要求array必须是数组
//	for (auto& e : array)
//	{
//		e *= 2;
//	}
//	for (auto& e : array)
//	{
//		cout << e << " ";
//	}
//	cout << endl;
//}


// 定义空指针
int main()
{
	// 两种空指针定义方式：
	// 1、
	int* p1 = NULL;
	// 2、
	int* p2 = nullptr;
	// 更加推荐使用第二种
	// 第一种NULL在C++中实际上是一个宏,并且其是用0去定义的
	// 因此可能会出现指针定义但被识别成为整形变量的误会

	return 0;
}
